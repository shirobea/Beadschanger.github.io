<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アイロンビーズカラー変換ソフト v1.3.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f8fafc;
        }
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* [FIX] Set background to white by default */
            background-color: white;
        }
        .preview-aspect-ratio {
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: contain;
        }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #e2e8f0; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .drag-over { border-color: #3b82f6; background-color: #eff6ff; }
        .disabled-panel { opacity: 0.5; pointer-events: none; }
        
        @media (max-width: 640px) {
            .mobile-hidden {
                display: none;
            }
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- [FIX] Header is no longer sticky -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center">
        <h1 class="text-lg md:text-xl font-bold text-slate-700">アイロンビーズカラー変換ソフト</h1>
        <span id="app-version" class="text-sm text-slate-500 bg-slate-100 px-2 py-1 rounded-full">v1.3.2</span>
    </header>

    <main class="container mx-auto p-4 md:p-6 lg:p-8 space-y-8">

        <section class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="bg-white p-6 rounded-lg shadow-md space-y-4">
                <h2 class="text-lg font-bold border-b pb-2">1. 画像の準備</h2>
                <label id="upload-area" for="file-input" class="border-2 border-dashed border-slate-300 rounded-lg p-8 text-center cursor-pointer block transition-colors hover:bg-slate-50">
                    <p class="text-slate-500">ここに画像をドラッグ＆ドロップ</p>
                    <p class="text-sm text-slate-400 my-2">または</p>
                    <span class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors inline-block">ファイルを選択</span>
                    <input type="file" id="file-input" class="hidden" accept="image/png, image/jpeg">
                </label>
            </div>

            <div id="settings-panel" class="bg-white p-6 rounded-lg shadow-md space-y-4 transition-opacity duration-300 disabled-panel">
                <h2 class="text-lg font-bold border-b pb-2">2. 変換設定</h2>
                
                <div>
                    <label class="font-bold">使用パレット</label>
                    <div class="flex flex-wrap gap-x-3 gap-y-2 mt-2" id="palette-filter">
                        <label class="flex items-center"><input type="radio" name="palette" value="all" class="mr-1" checked>両方</label>
                    </div>
                </div>

                <div>
                    <label class="font-bold">変換モード</label>
                    <div class="flex space-x-4 mt-2" id="conversion-mode">
                        <label class="flex items-center"><input type="radio" name="mode" value="normal" class="mr-1" checked>通常</label>
                        <label class="flex items-center"><input type="radio" name="mode" value="dithering" class="mr-1">多色 (ディザリング)</label>
                    </div>
                    <div id="dithering-strength-container" class="hidden mt-2">
                        <label for="dithering-strength" class="font-medium text-sm">ディザリング強度</label>
                        <input type="range" id="dithering-strength" min="0.1" max="1" step="0.1" value="0.7" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-slate-500 flex justify-between"><span>弱い</span><span>強い</span></div>
                    </div>
                </div>

                <div>
                    <label class="font-bold">変換後サイズ (px)</label>
                    <div class="flex items-center space-x-2 mt-2">
                        <input type="number" id="width-input" class="w-full border-slate-300 rounded-md shadow-sm" placeholder="幅">
                        <span class="text-slate-500">×</span>
                        <input type="number" id="height-input" class="w-full border-slate-300 rounded-md shadow-sm" placeholder="高さ">
                        <button id="reset-size-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-600 font-bold p-2 rounded-md transition-colors text-xl w-10 h-10 flex items-center justify-center flex-shrink-0">&#8635;</button>
                    </div>
                </div>

                <h2 class="text-lg font-bold border-b pb-2 mt-6">3. 変換の実行</h2>
                
                <button id="convert-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow">
                    変換実行
                </button>
                <div class="w-full bg-slate-200 rounded-full h-2.5 mt-2">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <p id="progress-text" class="text-center text-sm text-slate-500 h-4"></p>
            </div>
        </section>

        <section id="result-section" class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="bg-white p-4 rounded-lg shadow-md flex flex-col items-center justify-center">
                <h3 class="font-bold text-center mb-2">元の画像</h3>
                <canvas id="original-canvas" class="preview-aspect-ratio rounded-md cursor-pointer border"></canvas>
            </div>
            <!-- [MODIFIED] Added ID for scrolling -->
            <div id="result-container" class="bg-white p-4 rounded-lg shadow-md flex flex-col items-center justify-center space-y-4">
                <h3 class="font-bold text-center">変換後画像</h3>
                <canvas id="result-canvas" class="preview-aspect-ratio rounded-md cursor-pointer border"></canvas>
                <button id="download-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 disabled:bg-slate-300 disabled:cursor-not-allowed shadow" disabled>
                    変換後の画像をダウンロード
                </button>
            </div>
        </section>

        <section id="used-colors-section" class="hidden bg-white p-6 rounded-lg shadow-md w-full mx-auto">
            <h2 class="text-xl font-bold text-center mb-4">使用色リスト</h2>
            <div id="color-list-container" class="max-h-96 overflow-y-auto custom-scrollbar">
                <table class="w-full text-sm text-left table-fixed">
                    <thead class="text-xs text-slate-700 uppercase bg-slate-50 sticky top-0">
                        <tr>
                            <th scope="col" class="px-2 py-3 w-16">色</th>
                            <th scope="col" class="px-2 py-3 w-24">番号</th>
                            <th scope="col" class="px-2 py-3 mobile-hidden">色名</th>
                            <th scope="col" class="px-2 py-3 w-24 text-right">使用個数</th>
                        </tr>
                    </thead>
                    <tbody id="color-list-body"></tbody>
                </table>
            </div>
        </section>
    </main>

    <!-- [FIX] Modified modal structure for zoom-proof close button -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-40 flex items-center justify-center p-4">
        <div class="relative max-w-full max-h-full flex items-center justify-center">
            <canvas id="modal-canvas"></canvas>
        </div>
        <button id="close-modal-btn" class="fixed top-4 right-4 text-white bg-slate-800 rounded-full w-10 h-10 flex items-center justify-center text-2xl font-bold leading-none z-50">&times;</button>
    </div>

    <script id="worker-script" type="javascript/worker">
        let isCancelled = false;
        let beadPaletteMap = {};

        function findClosestColor(pixel, palette) {
            if (palette.length === 0) return null;
            let closestColor = palette[0];
            let minDistance = (pixel.r - closestColor.r) ** 2 + (pixel.g - closestColor.g) ** 2 + (pixel.b - closestColor.b) ** 2;
            for (let i = 1; i < palette.length; i++) {
                const color = palette[i];
                const distance = (pixel.r - color.r) ** 2 + (pixel.g - color.g) ** 2 + (pixel.b - color.b) ** 2;
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            return closestColor;
        }

        function doDitheringPass(originalData, width, height, palette, ditheringStrength) {
            const dataCopy = new Float32Array(originalData);
            const pixelMap = new Array(width * height);
            const counts = {};

            for (let y = 0; y < height; y++) {
                if (isCancelled) return { pixelMap: null, counts: null };
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x);
                    const i4 = i * 4;
                    const oldPixel = { r: dataCopy[i4], g: dataCopy[i4 + 1], b: dataCopy[i4 + 2] };
                    const newPixel = findClosestColor(oldPixel, palette);
                    if (!newPixel) continue;

                    pixelMap[i] = newPixel.no;
                    counts[newPixel.no] = (counts[newPixel.no] || 0) + 1;
                    
                    let errR = (oldPixel.r - newPixel.r) * ditheringStrength;
                    let errG = (oldPixel.g - newPixel.g) * ditheringStrength;
                    let errB = (oldPixel.b - newPixel.b) * ditheringStrength;
                    
                    if (x + 1 < width) {
                        const idx = i4 + 4;
                        dataCopy[idx] += errR * 7/16; dataCopy[idx+1] += errG * 7/16; dataCopy[idx+2] += errB * 7/16;
                    }
                    if (y + 1 < height) {
                        if (x > 0) {
                            const idx = i4 + (width - 1) * 4;
                            dataCopy[idx] += errR * 3/16; dataCopy[idx+1] += errG * 3/16; dataCopy[idx+2] += errB * 3/16;
                        }
                        const idx = i4 + width * 4;
                        dataCopy[idx] += errR * 5/16; dataCopy[idx+1] += errG * 5/16; dataCopy[idx+2] += errB * 5/16;
                        if (x + 1 < width) {
                            const idx = i4 + (width + 1) * 4;
                            dataCopy[idx] += errR * 1/16; dataCopy[idx+1] += errG * 1/16; dataCopy[idx+2] += errB * 1/16;
                        }
                    }
                }
                if(y % 5 === 0 || y === height - 1){
                    self.postMessage({ type: 'progress', current: y + 1, total: height, phase: 'dithering' });
                }
            }
            return { pixelMap, counts };
        }

        self.onmessage = (e) => {
            const { type, payload } = e.data;

            if (type === 'start') {
                isCancelled = false;
                try {
                    const { imageData, width, height, mode, activePalette, map, ditheringStrength } = payload;
                    beadPaletteMap = map;
                    const data = new Uint8ClampedArray(imageData);
                    let resultBuffer, resultCounts;

                    if (mode === 'normal') {
                        const convertedImageData = new Uint8ClampedArray(width * height * 4);
                        const counts = {};
                        for (let y = 0; y < height; y++) {
                             if (isCancelled) { self.postMessage({ type: 'cancelled' }); return; }
                             for (let x = 0; x < width; x++) {
                                const i = (y * width + x) * 4;
                                const pixel = { r: data[i], g: data[i+1], b: data[i+2] };
                                const closestColor = findClosestColor(pixel, activePalette);
                                if (closestColor) {
                                    convertedImageData[i] = closestColor.r;
                                    convertedImageData[i+1] = closestColor.g;
                                    convertedImageData[i+2] = closestColor.b;
                                    convertedImageData[i+3] = 255;
                                    counts[closestColor.no] = (counts[closestColor.no] || 0) + 1;
                                }
                             }
                             if(y % 5 === 0 || y === height - 1){
                                self.postMessage({ type: 'progress', current: y + 1, total: height });
                             }
                        }
                        resultBuffer = convertedImageData.buffer;
                        resultCounts = counts;
                    } else { // dithering
                        const { pixelMap, counts: initialCounts } = doDitheringPass(data, width, height, activePalette, ditheringStrength);
                        if (isCancelled) { self.postMessage({ type: 'cancelled' }); return; }

                        const totalPixels = width * height;
                        const RARE_THRESHOLD = totalPixels * 0.001;
                        const finalCounts = { ...initialCounts };
                        
                        const rareColorNos = Object.keys(finalCounts).filter(no => finalCounts[no] < RARE_THRESHOLD);
                        const commonColors = activePalette.filter(c => !rareColorNos.includes(c.no));
                        const replacementMap = {};

                        if (commonColors.length > 0 && commonColors.length < activePalette.length) {
                            rareColorNos.forEach(rareNo => {
                                const rareColor = beadPaletteMap[rareNo];
                                if (!rareColor) return;
                                const replacementColor = findClosestColor(rareColor, commonColors);
                                if (replacementColor) {
                                    replacementMap[rareNo] = replacementColor.no;
                                    finalCounts[replacementColor.no] = (finalCounts[replacementColor.no] || 0) + finalCounts[rareNo];
                                    delete finalCounts[rareNo];
                                }
                            });
                        }
                        
                        const convertedImageData = new Uint8ClampedArray(width * height * 4);
                        for(let i=0; i < pixelMap.length; i++) {
                            const originalColorNo = pixelMap[i];
                            const finalColorNo = replacementMap[originalColorNo] || originalColorNo;
                            const finalColor = beadPaletteMap[finalColorNo];
                            if (finalColor) {
                                convertedImageData[i * 4] = finalColor.r;
                                convertedImageData[i * 4 + 1] = finalColor.g;
                                convertedImageData[i * 4 + 2] = finalColor.b;
                                convertedImageData[i * 4 + 3] = 255;
                            }
                        }
                        resultBuffer = convertedImageData.buffer;
                        resultCounts = finalCounts;
                    }
                    self.postMessage({ type: 'complete', result: { buffer: resultBuffer, counts: resultCounts } }, [resultBuffer]);
                } catch (err) {
                    self.postMessage({ type: 'error', message: err.message });
                }
            } else if (type === 'cancel') {
                isCancelled = true;
            }
        };
    </script>


    <script type="module">
    const BEADS_CSV_URL = 'https://raw.githubusercontent.com/shirobea/Beadschanger.github.io/main/BeadsColors%20-%20BeadsColors.csv';
    
    let beadPalette = [];
    let beadPaletteMap = {};
    let originalImage = null;
    let originalAspectRatio = 1;
    let conversionWorker = null;
    let isConverting = false;

    const dom = {
        version: document.getElementById('app-version'),
        uploadArea: document.getElementById('upload-area'),
        fileInput: document.getElementById('file-input'),
        settingsPanel: document.getElementById('settings-panel'),
        paletteFilter: document.getElementById('palette-filter'),
        conversionMode: document.getElementById('conversion-mode'),
        ditheringContainer: document.getElementById('dithering-strength-container'),
        ditheringSlider: document.getElementById('dithering-strength'),
        widthInput: document.getElementById('width-input'),
        heightInput: document.getElementById('height-input'),
        resetSizeBtn: document.getElementById('reset-size-btn'),
        convertBtn: document.getElementById('convert-btn'),
        progressBar: document.getElementById('progress-bar'),
        progressText: document.getElementById('progress-text'),
        originalCanvas: document.getElementById('original-canvas'),
        resultCanvas: document.getElementById('result-canvas'),
        resultContainer: document.getElementById('result-container'),
        downloadBtn: document.getElementById('download-btn'),
        usedColorsSection: document.getElementById('used-colors-section'),
        colorListBody: document.getElementById('color-list-body'),
        modal: document.getElementById('modal'),
        modalCanvas: document.getElementById('modal-canvas'),
        modalCloseBtn: document.getElementById('close-modal-btn'),
    };

    async function initializeApp() {
        dom.version.textContent = `v1.3.2`;
        try {
            await loadBeadPalette();
            setupEventListeners();
        } catch (error) {
            alert(`アプリケーションの初期化に失敗しました: ${error.message}`);
        }
    }

    async function loadBeadPalette() {
        const rawCsvUrl = BEADS_CSV_URL.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const response = await fetch(rawCsvUrl);
        if (!response.ok) throw new Error('ビーズパレットの読み込みに失敗しました。');
        
        const csvText = await response.text();
        beadPalette = csvText.trim().split(/\r?\n/).slice(1).map(row => {
            const [no, name, r, g, b, categoryNum] = row.split(',').map(s => s.trim());
            if (!no || !r || !g || !b ) return null;
            const colorInfo = { no, name, r: parseInt(r), g: parseInt(g), b: parseInt(b), category: categoryNum };
            beadPaletteMap[no] = colorInfo;
            return colorInfo;
        }).filter(Boolean);
        
        beadPalette.forEach(c => {
             if (c.category === '0') c.categoryName = 'NicoRate';
             else if (c.category === '1') c.categoryName = 'フューズビーズ';
             else c.categoryName = 'その他';
        });
    }
    
    function remapPaletteForUI() {
        const categories = [...new Set(beadPalette.map(c => c.categoryName))].filter(Boolean);
        
        let html = '<label class="flex items-center"><input type="radio" name="palette" value="all" class="mr-1" checked>両方</label>';
        categories.forEach(catName => {
            html += `<label class="flex items-center"><input type="radio" name="palette" value="${catName}" class="mr-1">${catName}</label>`;
        });
        dom.paletteFilter.innerHTML = html;
    }

    function setupEventListeners() {
        ['dragover', 'dragenter'].forEach(ev => dom.uploadArea.addEventListener(ev, e => { e.preventDefault(); dom.uploadArea.classList.add('drag-over'); }));
        ['dragleave', 'drop'].forEach(ev => dom.uploadArea.addEventListener(ev, e => { e.preventDefault(); dom.uploadArea.classList.remove('drag-over'); }));
        dom.uploadArea.addEventListener('drop', (e) => { if (e.dataTransfer.files.length) handleImageUpload(e.dataTransfer.files[0]); });
        dom.fileInput.addEventListener('change', (e) => { if (e.target.files.length) handleImageUpload(e.target.files[0]); });

        dom.conversionMode.addEventListener('change', (e) => {
            dom.ditheringContainer.classList.toggle('hidden', e.target.value !== 'dithering');
        });

        dom.widthInput.addEventListener('input', () => handleSizeChange('width'));
        dom.heightInput.addEventListener('input', () => handleSizeChange('height'));
        dom.resetSizeBtn.addEventListener('click', resetSizeInputs);
        dom.convertBtn.addEventListener('click', toggleConversion);
        dom.downloadBtn.addEventListener('click', downloadImage);
        dom.originalCanvas.addEventListener('click', () => !isConverting && originalImage && showModal(dom.originalCanvas));
        dom.resultCanvas.addEventListener('click', () => !isConverting && dom.resultCanvas.width > 1 && showModal(dom.resultCanvas));
        dom.modal.addEventListener('click', (e) => { if (e.target === dom.modal) closeModal(); });
        dom.modalCloseBtn.addEventListener('click', closeModal);
        remapPaletteForUI();
    }

    function setUIState(converting, wasCancelled = false) {
        isConverting = converting;
        document.querySelectorAll('#settings-panel input, #settings-panel button').forEach(el => el.disabled = converting);

        if (converting) {
            dom.convertBtn.textContent = '変換を中止';
            dom.convertBtn.classList.replace('bg-blue-500', 'bg-red-500');
            dom.convertBtn.classList.replace('hover:bg-blue-600', 'hover:bg-red-600');
            dom.convertBtn.disabled = false;
        } else {
            dom.convertBtn.textContent = '変換実行';
            dom.convertBtn.classList.replace('bg-red-500', 'bg-blue-500');
            dom.convertBtn.classList.replace('hover:bg-red-600', 'hover:bg-blue-600');
            dom.progressText.textContent = wasCancelled ? '中止しました' : (dom.resultCanvas.width > 1 ? '完了' : '');
            dom.downloadBtn.disabled = (dom.resultCanvas.width <= 1);
        }
    }

    function updateProgress(current, total) {
        let percent = total > 0 ? Math.floor((current / total) * 100) : 0;
        dom.progressBar.style.width = `${percent}%`;
        dom.progressText.textContent = `変換中... ${percent}%`;
    }
    
    function handleImageUpload(file) {
        const ctx = dom.resultCanvas.getContext('2d');
        ctx.clearRect(0, 0, dom.resultCanvas.width, dom.resultCanvas.height);
        dom.resultCanvas.width = 1;
        dom.resultCanvas.height = 1;
        dom.downloadBtn.disabled = true;
        dom.usedColorsSection.classList.add('hidden');
        dom.progressText.textContent = '';
        dom.progressBar.style.width = '0%';

        const reader = new FileReader();
        reader.onload = (e) => {
            originalImage = new Image();
            originalImage.onload = () => {
                originalAspectRatio = originalImage.width / originalImage.height;
                drawToCanvas(dom.originalCanvas, originalImage);
                resetSizeInputs();
                dom.settingsPanel.classList.remove('disabled-panel');
                dom.settingsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            };
            originalImage.onerror = () => alert('画像ファイルの読み込みに失敗しました。');
            originalImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    function drawToCanvas(canvas, imageSource) {
        const ctx = canvas.getContext('2d');
        canvas.width = imageSource.width;
        canvas.height = imageSource.height;
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (imageSource instanceof ImageData) {
            ctx.putImageData(imageSource, 0, 0);
        } else {
            ctx.drawImage(imageSource, 0, 0, canvas.width, canvas.height);
        }
    }

    function handleSizeChange(changed) {
        if (!originalImage) return;
        const width = parseInt(dom.widthInput.value);
        const height = parseInt(dom.heightInput.value);
        if (changed === 'width' && width > 0) dom.heightInput.value = Math.round(width / originalAspectRatio) || 1;
        else if (changed === 'height' && height > 0) dom.widthInput.value = Math.round(height * originalAspectRatio) || 1;
    }

    function resetSizeInputs() {
        if (originalImage) {
            dom.widthInput.value = originalImage.width;
            dom.heightInput.value = originalImage.height;
        }
    }

    function killWorker() {
        if (conversionWorker) {
            conversionWorker.postMessage({ type: 'cancel' });
            conversionWorker.terminate();
            conversionWorker = null;
        }
    }

    function toggleConversion() {
        if (isConverting) {
            killWorker();
            setUIState(false, true);
        } else {
            startConversion();
        }
    }

    function startConversion() {
        if (!originalImage) return alert('最初に画像をアップロードしてください。');
        if (!beadPalette || beadPalette.length === 0) return alert('ビーズパレットが読み込まれていません。');
        
        const width = parseInt(dom.widthInput.value);
        const height = parseInt(dom.heightInput.value);
        if (!(width > 0 && height > 0)) return alert('有効な変換後サイズを指定してください。');
        
        setUIState(true);
        updateProgress(0, 100);
        dom.usedColorsSection.classList.add('hidden');

        const tempCtx = document.createElement('canvas').getContext('2d', { willReadFrequently: true });
        tempCtx.canvas.width = width;
        tempCtx.canvas.height = height;
        tempCtx.drawImage(originalImage, 0, 0, width, height);
        const imageData = tempCtx.getImageData(0, 0, width, height);
        
        dom.resultCanvas.width = width;
        dom.resultCanvas.height = height;
        
        killWorker();
        const workerScript = document.getElementById('worker-script').textContent;
        conversionWorker = new Worker(URL.createObjectURL(new Blob([workerScript])));

        conversionWorker.onmessage = (e) => {
            const { type, result, current, total, phase, message } = e.data;
            switch (type) {
                case 'progress':
                    updateProgress(current, total, phase);
                    break;
                case 'complete':
                    const finalImageData = new ImageData(new Uint8ClampedArray(result.buffer), width, height);
                    drawToCanvas(dom.resultCanvas, finalImageData);
                    displayColorList(result.counts);
                    setUIState(false);
                    killWorker();
                    dom.resultContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    break;
                case 'cancelled':
                    setUIState(false, true);
                    break;
                case 'error':
                    alert(`変換エラー: ${message}`);
                    setUIState(false);
                    killWorker();
                    break;
            }
        };
        conversionWorker.onerror = (err) => {
            alert(`ワーカーで致命的なエラーが発生しました: ${err.message}`);
            setUIState(false);
            killWorker();
        };

        const paletteFilterValue = dom.paletteFilter.querySelector('input:checked').value;
        const activePalette = beadPalette.filter(c => paletteFilterValue === 'all' || c.categoryName === paletteFilterValue);
        
        if (activePalette.length === 0) {
            alert('選択された条件に合うビーズがありません。');
            setUIState(false);
            return;
        }
        
        const payload = {
            imageData: imageData.data.buffer,
            width, height,
            mode: dom.conversionMode.querySelector('input:checked').value,
            ditheringStrength: parseFloat(dom.ditheringSlider.value),
            activePalette,
            map: beadPaletteMap,
        };
        conversionWorker.postMessage({ type: 'start', payload }, [payload.imageData]);
    }

    function displayColorList(colorCounts) {
        if (!colorCounts || Object.keys(colorCounts).length === 0) {
            dom.usedColorsSection.classList.add('hidden');
            return;
        }
        const countsArray = Object.entries(colorCounts).map(([no, count]) => ({
            ...(beadPaletteMap[no]), count
        }));

        countsArray.sort((a, b) => b.count - a.count);
        dom.colorListBody.innerHTML = '';
        countsArray.forEach(color => {
            if (!color) return;
            const hex = `rgb(${color.r}, ${color.g}, ${color.b})`;
            const row = `
                <tr class="bg-white border-b hover:bg-slate-50">
                    <td class="px-2 py-2"><div class="w-6 h-6 rounded-full border border-slate-300 mx-auto" style="background-color: ${hex};"></div></td>
                    <td class="px-2 py-2 font-medium text-slate-900 text-center">${color.no}</td>
                    <td class="px-2 py-2 truncate mobile-hidden">${color.name}</td>
                    <td class="px-2 py-2 text-right">${color.count.toLocaleString()}</td>
                </tr>`;
            dom.colorListBody.insertAdjacentHTML('beforeend', row);
        });
        dom.usedColorsSection.classList.remove('hidden');
    }

    function downloadImage() {
        if (dom.resultCanvas.width <= 1) return;
        const link = document.createElement('a');
        link.download = 'bead-art.png';
        link.href = dom.resultCanvas.toDataURL('image/png');
        link.click();
    }
    
    function showModal(sourceCanvas) {
        if (sourceCanvas.width <= 1 || sourceCanvas.height <= 1) return;
        const modalCanvasCtx = dom.modalCanvas.getContext('2d');
        modalCanvasCtx.imageSmoothingEnabled = false; 

        dom.modalCanvas.width = sourceCanvas.width;
        dom.modalCanvas.height = sourceCanvas.height;
        modalCanvasCtx.fillStyle = '#FFFFFF';
        modalCanvasCtx.fillRect(0, 0, dom.modalCanvas.width, dom.modalCanvas.height);
        modalCanvasCtx.drawImage(sourceCanvas, 0, 0);

        const modalAspectRatio = sourceCanvas.width / sourceCanvas.height;
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        let displayWidth = screenWidth * 0.9;
        let displayHeight = displayWidth / modalAspectRatio;

        if (displayHeight > screenHeight * 0.9) {
            displayHeight = screenHeight * 0.9;
            displayWidth = displayHeight * modalAspectRatio;
        }

        dom.modalCanvas.style.width = `${displayWidth}px`;
        dom.modalCanvas.style.height = `${displayHeight}px`;
        dom.modal.classList.replace('hidden', 'flex');
    }

    function closeModal() {
        dom.modal.classList.replace('flex', 'hidden');
    }

    initializeApp();
    </script>
</body>
</html>
