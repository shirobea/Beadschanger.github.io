<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アイロンビーズカラー変換ソフト v1.4.1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
    <style>
        html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f8fafc;
        }
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* [FIX] Set background to white by default */
            background-color: white;
        }
        .preview-aspect-ratio {
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: contain;
        }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #e2e8f0; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .drag-over { border-color: #3b82f6; background-color: #eff6ff; }
        .disabled-panel { opacity: 0.5; pointer-events: none; }
        /* 画像アップロード枠の高さを変換設定パネルと揃える */
        #upload-area {
            min-height: 340px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        /* サイズ入力欄の幅を狭める */
        #width-input, #height-input {
            max-width: 80px;
            min-width: 0;
        }
        /* 使用色リストの行の状態ごとの色分け */
        #color-list-body tr {
            transition: background 0.15s, color 0.15s;
        }
        #color-list-body tr.selected-row {
            background-color: #2563eb !important; /* 濃い青 */
            color: #fff;
        }
        #color-list-body tr.selected-row:hover {
            background-color: #60a5fa !important; /* 少し薄い青 */
            color: #fff;
        }
        #color-list-body tr:not(.selected-row):hover {
            background-color: #e0e7ef !important; /* さらに薄い青 */
            color: #222;
        }
        #color-list-body tr:not(.selected-row) {
            background-color: #fff !important; /* 未選択: 白 */
            color: #222;
        }
        @media (max-width: 640px) {
            .mobile-hidden {
                display: none;
            }
        }
    </style>
</head>
<body class="text-slate-800">

    <!-- [FIX] Header is no longer sticky -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center">
        <h1 class="text-lg md:text-xl font-bold text-slate-700">アイロンビーズカラー変換ソフト</h1>
        <span id="app-version" class="text-sm text-slate-500 bg-slate-100 px-2 py-1 rounded-full">v1.4.1</span>
    </header>
    <!-- エラーメッセージ表示用 -->
    <div id="error-message" class="hidden w-full bg-red-100 text-red-700 text-center py-2"></div>

    <main class="container mx-auto p-4 md:p-6 lg:p-8 space-y-8">

        <section class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="bg-white p-6 rounded-lg shadow-md space-y-4">
                <h2 class="text-lg font-bold border-b pb-2">1. 画像の準備</h2>
                <label id="upload-area" for="file-input" class="border-2 border-dashed border-slate-300 rounded-lg p-8 text-center cursor-pointer block transition-colors hover:bg-slate-50">
                    <p class="text-slate-500">ここに画像をドラッグ＆ドロップ</p>
                    <p class="text-sm text-slate-400 my-2">または</p>
                    <label for="file-input" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors inline-block cursor-pointer" aria-label="ファイルを選択">ファイルを選択</label>
                    <input type="file" id="file-input" class="hidden" accept="image/png, image/jpeg">
                </label>
            </div>

            <div id="settings-panel" class="bg-white p-6 rounded-lg shadow-md space-y-4 transition-opacity duration-300 disabled-panel">
                <h2 class="text-lg font-bold border-b pb-2">2. 変換設定</h2>
                
                <div>
                    <label class="font-bold">使用パレット</label>
                    <div class="flex flex-wrap gap-x-3 gap-y-2 mt-2" id="palette-filter">
                        <label class="flex items-center"><input type="radio" name="palette" value="all" class="mr-1" checked>両方</label>
                    </div>
                </div>

                <div>
                    <label class="font-bold">変換モード</label>
                    <div class="flex space-x-4 mt-2" id="conversion-mode">
                        <label class="flex items-center"><input type="radio" name="mode" value="normal" class="mr-1" checked>通常</label>
                        <label class="flex items-center"><input type="radio" name="mode" value="dithering" class="mr-1">多色 (ディザリング)</label>
                    </div>
                    <div id="dithering-strength-container" class="hidden mt-2">
                        <label for="dithering-strength" class="font-medium text-sm">ディザリング強度</label>
                        <input type="range" id="dithering-strength" min="0.1" max="1" step="0.1" value="0.7" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                        <div class="text-xs text-slate-500 flex justify-between"><span>弱い</span><span>強い</span></div>
                    </div>
                </div>

                <div>
                    <!-- プレート選択ラジオボタンを先に -->
                    <div class="mt-2 flex flex-wrap gap-4 items-center">
                        <span class="font-bold">使用プレート:</span>
                        <label class="flex items-center"><input type="radio" name="plate" value="nicorate" class="mr-1" checked>NicoRate (50×50)</label>
                        <label class="flex items-center"><input type="radio" name="plate" value="fuse" class="mr-1">フューズビーズミニ (27×27)</label>
                        <label class="flex items-center"><input type="radio" name="plate" value="nano" class="mr-1">ナノビーズ (28×28)</label>
                    </div>
                    <!-- 変換後サイズ(px)入力欄を後に -->
                    <label class="font-bold mt-4">変換後サイズ (px)</label>
                    <div class="flex items-center space-x-2 mt-2">
                        <input type="number" id="height-input" class="w-full border-slate-300 rounded-md shadow-sm" placeholder="高さ" aria-label="高さ">
                        <span class="text-slate-500">×</span>
                        <input type="number" id="width-input" class="w-full border-slate-300 rounded-md shadow-sm" placeholder="幅" aria-label="幅">
                        <button id="reset-size-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-600 font-bold p-2 rounded-md transition-colors text-xl w-10 h-10 flex items-center justify-center flex-shrink-0" aria-label="サイズをリセット">&#8635;</button>
                        <!-- 追加: 1/2, 1/4ボタン -->
                        <button id="half-size-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-600 font-bold p-2 rounded-md transition-colors text-base w-10 h-10 flex items-center justify-center flex-shrink-0 ml-1" aria-label="サイズを1/2">1/2</button>
                        <button id="flip-horizontal-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-600 font-bold p-2 rounded-md transition-colors text-base w-10 h-10 flex items-center justify-center flex-shrink-0 ml-1" aria-label="左右反転">⇄</button>
                        <label class="flex items-center ml-2"><input type="checkbox" id="aspect-lock" class="mr-1" checked aria-checked="true" aria-label="比率固定">比率固定</label>
                    </div>
                    <!-- 作品サイズ表示（フォント大きめに） -->
                    <div id="bead-size-info" class="text-base text-slate-700 mt-2 font-bold"></div>
                    <!-- プレート必要数表示（下に移動・大きめ） -->
                    <div id="plate-info" class="text-base text-slate-600 mt-1 font-bold"></div>
                </div>
            </div>
        </section>

        <!-- 変換実行ボタンと進捗バーを画像プレビューの上に移動 -->
        <div class="w-full flex justify-center mt-4">
            <button id="convert-btn" class="w-full max-w-xs bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow" aria-label="変換実行">
                変換実行
            </button>
        </div>
        <div class="w-full max-w-md mx-auto bg-slate-200 rounded-full h-2.5 mt-2">
            <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
        <p id="progress-text" class="text-center text-sm text-slate-500 h-4"></p>

        <section id="result-section" class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="bg-white p-4 rounded-lg shadow-md flex flex-col items-center justify-center h-full min-h-[420px]">
                <h3 class="font-bold text-center mb-2">元の画像</h3>
                <canvas id="original-canvas" class="preview-aspect-ratio rounded-md cursor-pointer border"></canvas>
            </div>
            <div id="result-container" class="bg-white p-4 rounded-lg shadow-md flex flex-col items-center justify-center space-y-2 h-full min-h-[420px]">
                <h3 class="font-bold text-center">変換後画像</h3>
                <canvas id="result-canvas" class="preview-aspect-ratio rounded-md cursor-pointer border"></canvas>
            </div>
        </section>
        <!-- ダウンロードボタンと説明文を枠外・下部に移動 -->
        <div class="w-full flex justify-center mt-4 gap-2">
            <button id="download-btn" class="w-full max-w-xs bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 disabled:bg-slate-300 disabled:cursor-not-allowed shadow" disabled aria-label="変換後の画像をダウンロード">
                変換後の画像をダウンロード
            </button>
            <button id="grid-toggle-btn" class="w-full max-w-xs bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow" aria-label="グリッド表示切替">
                グリッド表示
            </button>
            <button id="clear-filter-btn" class="w-full max-w-xs bg-slate-400 hover:bg-slate-500 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow" style="display:none;" aria-label="色選択解除">
                選択解除
            </button>
            <!-- 背景除去ボタンとスライダー追加 -->
            <button id="remove-bg-btn" class="w-full max-w-xs bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-300 shadow" aria-label="背景除去">
                除去オフ
            </button>
            <div id="remove-bg-tolerance-container" class="flex items-center gap-2" style="display:none;">
                <label for="remove-bg-tolerance" class="text-sm">色差許容度</label>
                <input type="range" id="remove-bg-tolerance" min="0" max="100" value="50" class="w-32">
                <span id="remove-bg-tolerance-value" class="text-xs">50</span>
            </div>
        </div>
        <p id="download-hint" class="text-center text-slate-400 text-xs mt-1">変換後画像がありません</p>

        <section id="used-colors-section" class="hidden bg-white p-6 rounded-lg shadow-md w-full mx-auto">
            <h2 class="text-xl font-bold text-center mb-4">使用色リスト</h2>
            <!-- 並び替えボタン群（2つにまとめる） -->
            <div class="flex flex-wrap justify-center gap-2 mb-2">
                <button id="sort-count-toggle" class="bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-1 rounded text-xs">使用個数 降順</button>
                <button id="sort-luminance-toggle" class="bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-1 rounded text-xs">色の濃さ 濃い順</button>
            </div>
            <div id="color-list-container" class="max-h-96 overflow-y-auto custom-scrollbar">
                <table class="w-full text-sm text-left table-fixed">
                    <thead class="text-xs text-slate-700 uppercase bg-slate-50 sticky top-0">
                        <tr>
                            <th scope="col" class="px-2 py-3 w-16">色</th>
                            <th scope="col" class="px-2 py-3 w-24">番号</th>
                            <th scope="col" class="px-2 py-3 mobile-hidden">色名</th>
                            <th scope="col" class="px-2 py-3 w-24 text-right">使用個数</th>
                        </tr>
                    </thead>
                    <tbody id="color-list-body"></tbody>
                </table>
            </div>
        </section>
    </main>

    <!-- [FIX] Modified modal structure for zoom-proof close button -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-40 flex items-center justify-center p-4">
        <div class="relative max-w-full max-h-full flex items-center justify-center">
            <canvas id="modal-canvas"></canvas>
        </div>
        <button id="close-modal-btn" class="fixed top-4 right-4 text-white bg-slate-800 rounded-full w-10 h-10 flex items-center justify-center text-2xl font-bold leading-none z-50" aria-label="モーダルを閉じる">&times;</button>
    </div>

    <script id="worker-script" type="javascript/worker">
        let isCancelled = false;
        let beadPaletteMap = {};

        function findClosestColor(pixel, palette) {
            if (palette.length === 0) return null;
            let closestColor = palette[0];
            let minDistance = (pixel.r - closestColor.r) ** 2 + (pixel.g - closestColor.g) ** 2 + (pixel.b - closestColor.b) ** 2;
            for (let i = 1; i < palette.length; i++) {
                const color = palette[i];
                const distance = (pixel.r - color.r) ** 2 + (pixel.g - color.g) ** 2 + (pixel.b - color.b) ** 2;
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            return closestColor;
        }

        function doDitheringPass(originalData, width, height, palette, ditheringStrength) {
            const dataCopy = new Float32Array(originalData);
            const pixelMap = new Array(width * height);
            const counts = {};

            for (let y = 0; y < height; y++) {
                if (isCancelled) return { pixelMap: null, counts: null };
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x);
                    const i4 = i * 4;
                    const oldPixel = { r: dataCopy[i4], g: dataCopy[i4 + 1], b: dataCopy[i4 + 2] };
                    const newPixel = findClosestColor(oldPixel, palette);
                    if (!newPixel) continue;

                    pixelMap[i] = newPixel.no;
                    counts[newPixel.no] = (counts[newPixel.no] || 0) + 1;
                    
                    let errR = (oldPixel.r - newPixel.r) * ditheringStrength;
                    let errG = (oldPixel.g - newPixel.g) * ditheringStrength;
                    let errB = (oldPixel.b - newPixel.b) * ditheringStrength;
                    
                    if (x + 1 < width) {
                        const idx = i4 + 4;
                        dataCopy[idx] += errR * 7/16; dataCopy[idx+1] += errG * 7/16; dataCopy[idx+2] += errB * 7/16;
                    }
                    if (y + 1 < height) {
                        if (x > 0) {
                            const idx = i4 + (width - 1) * 4;
                            dataCopy[idx] += errR * 3/16; dataCopy[idx+1] += errG * 3/16; dataCopy[idx+2] += errB * 3/16;
                        }
                        const idx = i4 + width * 4;
                        dataCopy[idx] += errR * 5/16; dataCopy[idx+1] += errG * 5/16; dataCopy[idx+2] += errB * 5/16;
                        if (x + 1 < width) {
                            const idx = i4 + (width + 1) * 4;
                            dataCopy[idx] += errR * 1/16; dataCopy[idx+1] += errG * 1/16; dataCopy[idx+2] += errB * 1/16;
                        }
                    }
                }
                if(y % 5 === 0 || y === height - 1){
                    self.postMessage({ type: 'progress', current: y + 1, total: height, phase: 'dithering' });
                }
            }
            return { pixelMap, counts };
        }

        self.onmessage = (e) => {
            const { type, payload } = e.data;

            if (type === 'start') {
                isCancelled = false;
                try {
                    const { imageData, width, height, mode, activePalette, map, ditheringStrength } = payload;
                    beadPaletteMap = map;
                    const data = new Uint8ClampedArray(imageData);
                    let resultBuffer, resultCounts;

                    if (mode === 'normal') {
                        const convertedImageData = new Uint8ClampedArray(width * height * 4);
                        const counts = {};
                        for (let y = 0; y < height; y++) {
                             if (isCancelled) { self.postMessage({ type: 'cancelled' }); return; }
                             for (let x = 0; x < width; x++) {
                                const i = (y * width + x) * 4;
                                const pixel = { r: data[i], g: data[i+1], b: data[i+2] };
                                const closestColor = findClosestColor(pixel, activePalette);
                                if (closestColor) {
                                    convertedImageData[i] = closestColor.r;
                                    convertedImageData[i+1] = closestColor.g;
                                    convertedImageData[i+2] = closestColor.b;
                                    convertedImageData[i+3] = 255;
                                    counts[closestColor.no] = (counts[closestColor.no] || 0) + 1;
                                }
                             }
                             if(y % 5 === 0 || y === height - 1){
                                self.postMessage({ type: 'progress', current: y + 1, total: height });
                             }
                        }
                        resultBuffer = convertedImageData.buffer;
                        resultCounts = counts;
                    } else { // dithering
                        const { pixelMap, counts: initialCounts } = doDitheringPass(data, width, height, activePalette, ditheringStrength);
                        if (isCancelled) { self.postMessage({ type: 'cancelled' }); return; }

                        const totalPixels = width * height;
                        const RARE_THRESHOLD = totalPixels * 0.001;
                        const finalCounts = { ...initialCounts };
                        
                        const rareColorNos = Object.keys(finalCounts).filter(no => finalCounts[no] < RARE_THRESHOLD);
                        const commonColors = activePalette.filter(c => !rareColorNos.includes(c.no));
                        const replacementMap = {};

                        if (commonColors.length > 0 && commonColors.length < activePalette.length) {
                            rareColorNos.forEach(rareNo => {
                                const rareColor = beadPaletteMap[rareNo];
                                if (!rareColor) return;
                                const replacementColor = findClosestColor(rareColor, commonColors);
                                if (replacementColor) {
                                    replacementMap[rareNo] = replacementColor.no;
                                    finalCounts[replacementColor.no] = (finalCounts[replacementColor.no] || 0) + finalCounts[rareNo];
                                    delete finalCounts[rareNo];
                                }
                            });
                        }
                        
                        const convertedImageData = new Uint8ClampedArray(width * height * 4);
                        for(let i=0; i < pixelMap.length; i++) {
                            const originalColorNo = pixelMap[i];
                            const finalColorNo = replacementMap[originalColorNo] || originalColorNo;
                            const finalColor = beadPaletteMap[finalColorNo];
                            if (finalColor) {
                                convertedImageData[i * 4] = finalColor.r;
                                convertedImageData[i * 4 + 1] = finalColor.g;
                                convertedImageData[i * 4 + 2] = finalColor.b;
                                convertedImageData[i * 4 + 3] = 255;
                            }
                        }
                        resultBuffer = convertedImageData.buffer;
                        resultCounts = finalCounts;
                    }
                    self.postMessage({ type: 'complete', result: { buffer: resultBuffer, counts: resultCounts } }, [resultBuffer]);
                } catch (err) {
                    self.postMessage({ type: 'error', message: err.message });
                }
            } else if (type === 'cancel') {
                isCancelled = true;
            }
        };
    </script>


    <script type="module">
    const BEADS_CSV_URL = 'https://raw.githubusercontent.com/shirobea/Beadschanger.github.io/main/BeadsColors%20-%20BeadsColors.csv';
    
    const appState = {
        beadPalette: [],
        beadPaletteMap: {},
        originalImage: null,
        originalAspectRatio: 1,
        conversionWorker: null,
        isConverting: false,
        resultImageData: null,
        resultWidth: 0,
        resultHeight: 0,
        filterColorNos: [],
        // 並び順状態
        sortType: 'count-desc', // 初期値は「使用個数 降順」
        showGrid: false,
        removeBgMode: false,
        removeBgTolerance: 50,
    };

    const dom = {
        version: document.getElementById('app-version'),
        uploadArea: document.getElementById('upload-area'),
        fileInput: document.getElementById('file-input'),
        settingsPanel: document.getElementById('settings-panel'),
        paletteFilter: document.getElementById('palette-filter'),
        conversionMode: document.getElementById('conversion-mode'),
        ditheringContainer: document.getElementById('dithering-strength-container'),
        ditheringSlider: document.getElementById('dithering-strength'),
        widthInput: document.getElementById('width-input'),
        heightInput: document.getElementById('height-input'),
        resetSizeBtn: document.getElementById('reset-size-btn'),
        convertBtn: document.getElementById('convert-btn'),
        progressBar: document.getElementById('progress-bar'),
        progressText: document.getElementById('progress-text'),
        originalCanvas: document.getElementById('original-canvas'),
        resultCanvas: document.getElementById('result-canvas'),
        resultContainer: document.getElementById('result-container'),
        downloadBtn: document.getElementById('download-btn'),
        usedColorsSection: document.getElementById('used-colors-section'),
        colorListBody: document.getElementById('color-list-body'),
        modal: document.getElementById('modal'),
        modalCanvas: document.getElementById('modal-canvas'),
        modalCloseBtn: document.getElementById('close-modal-btn'),
        aspectLock: document.getElementById('aspect-lock'),
        clearFilterBtn: document.getElementById('clear-filter-btn'),
        gridToggleBtn: document.getElementById('grid-toggle-btn'),
        colorReduceContainer: document.getElementById('color-reduce-container'),
        colorReduceSlider: document.getElementById('color-reduce-slider'),
        colorReduceMaxLabel: document.getElementById('color-reduce-max-label'),
    };

    // エラーメッセージをUI表示する関数
    function showError(message) {
        const errorDiv = document.getElementById('error-message');
        if (!errorDiv) return;
        errorDiv.textContent = message;
        errorDiv.classList.remove('hidden');
        // 5秒後に自動で消す
        setTimeout(() => {
            errorDiv.classList.add('hidden');
            errorDiv.textContent = '';
        }, 5000);
    }

    async function initializeApp() {
        dom.version.textContent = `v1.4.1`;
        dom.downloadBtn.disabled = true;
        const downloadHint = document.getElementById('download-hint');
        if (downloadHint) downloadHint.style.display = '';
        handleSizeChange();
        // 色差許容度スライダー初期化
        const removeBgTolerance = document.getElementById('remove-bg-tolerance');
        const removeBgToleranceValue = document.getElementById('remove-bg-tolerance-value');
        if (removeBgTolerance) removeBgTolerance.value = 50;
        if (removeBgToleranceValue) removeBgToleranceValue.textContent = '50';
        appState.removeBgTolerance = 50;
        // 比率固定チェックボックスを常にチェック状態に設定
        if (dom.aspectLock) {
            dom.aspectLock.checked = true;
        }
        try {
            await loadBeadPalette();
            setupEventListeners();
            // --- 追加: 設定の復元 ---
            restoreRadioSetting('palette');
            restoreRadioSetting('mode');
            restoreRadioSetting('plate');
            // 追加: 多色モード選択時はディザリングバーを表示
            const modeRadio = document.querySelector('input[name="mode"]:checked');
            if (modeRadio && modeRadio.value === 'dithering') {
                dom.ditheringContainer.classList.remove('hidden');
            } else {
                dom.ditheringContainer.classList.add('hidden');
            }
            if (removeBgBtn) removeBgBtn.textContent = '除去オフ';
        } catch (error) {
            // 初期化失敗時のエラーメッセージ表示を削除
        }
    }

    async function loadBeadPalette() {
        const rawCsvUrl = BEADS_CSV_URL.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        const response = await fetch(rawCsvUrl);
        if (!response.ok) throw new Error('ビーズパレットの読み込みに失敗しました。');
        
        const csvText = await response.text();
        appState.beadPalette = csvText.trim().split(/\r?\n/).slice(1).map(row => {
            const [no, name, r, g, b, categoryNum] = row.split(',').map(s => s.trim());
            if (!no || !r || !g || !b ) return null;
            const colorInfo = { no, name, r: parseInt(r), g: parseInt(g), b: parseInt(b), category: categoryNum };
            appState.beadPaletteMap[no] = colorInfo;
            return colorInfo;
        }).filter(Boolean);
        
        appState.beadPalette.forEach(c => {
            if (c.category === '0') c.categoryName = 'NicoRate';
            else if (c.category === '1') c.categoryName = 'フューズビーズミニ';
            else c.categoryName = 'その他';
        });
    }
    
    function remapPaletteForUI() {
        const categories = [...new Set(appState.beadPalette.map(c => c.categoryName))].filter(Boolean);
        const container = dom.paletteFilter;
        container.innerHTML = '';

        // 「両方」ラジオボタン
        const labelAll = document.createElement('label');
        labelAll.className = 'flex items-center';
        const radioAll = document.createElement('input');
        radioAll.type = 'radio';
        radioAll.name = 'palette';
        radioAll.value = 'all';
        radioAll.className = 'mr-1';
        radioAll.checked = true;
        labelAll.appendChild(radioAll);
        labelAll.appendChild(document.createTextNode('両方'));
        container.appendChild(labelAll);

        // 各カテゴリのラジオボタン
        categories.forEach(catName => {
            const label = document.createElement('label');
            label.className = 'flex items-center';
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'palette';
            radio.value = catName;
            radio.className = 'mr-1';
            label.appendChild(radio);
            label.appendChild(document.createTextNode(catName));
            container.appendChild(label);
        });
    }

    function setupEventListeners() {
        ['dragover', 'dragenter'].forEach(ev => dom.uploadArea.addEventListener(ev, e => { e.preventDefault(); dom.uploadArea.classList.add('drag-over'); }));
        ['dragleave', 'drop'].forEach(ev => dom.uploadArea.addEventListener(ev, e => { e.preventDefault(); dom.uploadArea.classList.remove('drag-over'); }));
        dom.uploadArea.addEventListener('drop', (e) => { if (e.dataTransfer.files.length) handleImageUpload(e.dataTransfer.files[0]); });
        dom.fileInput.addEventListener('change', (e) => { if (e.target.files.length) handleImageUpload(e.target.files[0]); });

        dom.conversionMode.addEventListener('change', (e) => {
            dom.ditheringContainer.classList.toggle('hidden', e.target.value !== 'dithering');
            saveRadioSetting('mode');
        });

        dom.widthInput.addEventListener('input', () => handleSizeChange('width'));
        dom.heightInput.addEventListener('input', () => handleSizeChange('height'));
        dom.resetSizeBtn.addEventListener('click', resetSizeInputs);
        dom.convertBtn.addEventListener('click', toggleConversion);
        dom.downloadBtn.addEventListener('click', downloadImage);
        dom.originalCanvas.addEventListener('click', () => !appState.isConverting && appState.originalImage && showModal(dom.originalCanvas));
        dom.resultCanvas.addEventListener('click', () => !appState.isConverting && dom.resultCanvas.width > 1 && showModal(dom.resultCanvas));
        dom.modal.addEventListener('click', (e) => { if (e.target === dom.modal) closeModal(); });
        dom.modalCloseBtn.addEventListener('click', closeModal);
        remapPaletteForUI();
        dom.clearFilterBtn.addEventListener('click', () => {
            appState.filterColorNos = [];
            drawFilteredResult();
            dom.clearFilterBtn.style.display = 'none';
            // 選択色の見た目もリセット
            displayColorList(appState.lastColorCounts);
        });
        // グリッド表示ボタン
        dom.gridToggleBtn.addEventListener('click', () => {
            appState.showGrid = !appState.showGrid;
            drawFilteredResult();
            dom.gridToggleBtn.textContent = appState.showGrid ? 'グリッド解除' : 'グリッド表示';
        });
        // 並び替えボタン
        document.getElementById('sort-count-toggle').addEventListener('click', () => {
            appState.sortType = appState.sortType === 'count-desc' ? 'count-asc' : 'count-desc';
            displayColorList(appState.lastColorCounts);
        });
        document.getElementById('sort-luminance-toggle').addEventListener('click', () => {
            // 最初に押したときは必ず「濃い（黒に近い色）が上」
            if (appState.sortType !== 'luminance-desc' && appState.sortType !== 'luminance-asc') {
                appState.sortType = 'luminance-asc'; // luminance値が小さいほど黒い
            } else {
                appState.sortType = appState.sortType === 'luminance-asc' ? 'luminance-desc' : 'luminance-asc';
            }
            displayColorList(appState.lastColorCounts);
        });
        // 色リストのスクロール時はページスクロールを防止
        const colorListContainer = document.getElementById('color-list-container');
        if (colorListContainer) {
            colorListContainer.addEventListener('wheel', (e) => {
                const atTop = colorListContainer.scrollTop === 0;
                const atBottom = colorListContainer.scrollHeight - colorListContainer.scrollTop === colorListContainer.clientHeight;
                if ((e.deltaY < 0 && atTop) || (e.deltaY > 0 && atBottom)) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        document.querySelectorAll('input[name="plate"]').forEach(radio => {
            radio.addEventListener('change', () => {
                handleSizeChange();
                saveRadioSetting('plate');
            });
        });
        // パレットラジオボタン
        dom.paletteFilter.addEventListener('change', (e) => {
            if (e.target && e.target.name === 'palette') {
                saveRadioSetting('palette');
            }
        });
        // 初期化時にも最大値をセット
        updateColorReduceSliderMax();
        // 追加: 1/2, 1/4ボタンのイベント
        document.getElementById('half-size-btn').addEventListener('click', () => {
            if (!appState.originalImage) return;
            let width = Math.max(1, Math.round(parseInt(dom.widthInput.value) / 2));
            let height = Math.max(1, Math.round(parseInt(dom.heightInput.value) / 2));
            dom.widthInput.value = width;
            dom.heightInput.value = height;
            handleSizeChange();
        });
        // 左右反転ボタン
        document.getElementById('flip-horizontal-btn').addEventListener('click', () => {
            if (!appState.originalImage) return;
            // 新しいImageインスタンスを作成し、左右反転した画像を生成
            const canvas = document.createElement('canvas');
            canvas.width = appState.originalImage.width;
            canvas.height = appState.originalImage.height;
            const ctx = canvas.getContext('2d');
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(appState.originalImage, 0, 0);
            // 新しいImageオブジェクトに反映
            const flippedImg = new window.Image();
            flippedImg.onload = () => {
                appState.originalImage = flippedImg;
                appState.originalAspectRatio = flippedImg.width / flippedImg.height;
                drawToCanvas(dom.originalCanvas, flippedImg);
                resetSizeInputs();
            };
            flippedImg.src = canvas.toDataURL();
        });
        // 背景除去ボタン・スライダー
        const removeBgBtn = document.getElementById('remove-bg-btn');
        const removeBgTolerance = document.getElementById('remove-bg-tolerance');
        const removeBgToleranceContainer = document.getElementById('remove-bg-tolerance-container');
        const removeBgToleranceValue = document.getElementById('remove-bg-tolerance-value');
        removeBgBtn.addEventListener('click', () => {
            // ON→OFF（復元処理）
            if (appState.removeBgMode) {
                if (appState.resultImageDataOriginal) {
                    appState.resultImageData = new ImageData(
                        new Uint8ClampedArray(appState.resultImageDataOriginal.data),
                        appState.resultWidth, appState.resultHeight
                    );
                }
                if (appState.lastColorCountsOriginal) {
                    appState.lastColorCounts = {...appState.lastColorCountsOriginal};
                }
                drawFilteredResult();
                displayColorList(appState.lastColorCounts);
            }
            appState.removeBgMode = !appState.removeBgMode;
            removeBgBtn.classList.toggle('bg-pink-700', appState.removeBgMode);
            removeBgToleranceContainer.style.display = appState.removeBgMode ? '' : 'none';
            removeBgBtn.textContent = appState.removeBgMode ? '除去オン' : '除去オフ';
        });
        removeBgTolerance.addEventListener('input', () => {
            appState.removeBgTolerance = parseInt(removeBgTolerance.value);
            removeBgToleranceValue.textContent = appState.removeBgTolerance;
        });
        // モーダルcanvasクリック時の背景除去
        dom.modalCanvas.addEventListener('click', (e) => {
            if (!appState.removeBgMode) return;
            if (!appState.resultImageData) return;
            const rect = dom.modalCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) * appState.resultWidth / rect.width);
            const y = Math.floor((e.clientY - rect.top) * appState.resultHeight / rect.height);
            removeBackgroundFloodFill(x, y, appState.removeBgTolerance);
            // モーダルの画像も再描画（filterColorNosを反映）
            drawFilteredModalResult();
        });
    }

    function setUIState(converting, wasCancelled = false) {
        appState.isConverting = converting;
        document.querySelectorAll('#settings-panel input, #settings-panel button').forEach(el => el.disabled = converting);

        // ダウンロードヒントの表示制御
        const downloadHint = document.getElementById('download-hint');
        if (dom.resultCanvas.width <= 1) {
            dom.downloadBtn.disabled = true;
            if (downloadHint) downloadHint.style.display = '';
        } else {
            dom.downloadBtn.disabled = false;
            if (downloadHint) downloadHint.style.display = 'none';
        }

        if (converting) {
            dom.convertBtn.textContent = '変換を中止';
            dom.convertBtn.classList.replace('bg-blue-500', 'bg-red-500');
            dom.convertBtn.classList.replace('hover:bg-blue-600', 'hover:bg-red-600');
            dom.convertBtn.disabled = false;
        } else {
            dom.convertBtn.textContent = '変換実行';
            dom.convertBtn.classList.replace('bg-red-500', 'bg-blue-500');
            dom.convertBtn.classList.replace('hover:bg-red-600', 'hover:bg-blue-600');
            dom.progressText.textContent = wasCancelled ? '中止しました' : (dom.resultCanvas.width > 1 ? '完了' : '');
        }
    }

    function updateProgress(current, total, phase) {
        let percent = total > 0 ? Math.floor((current / total) * 100) : 0;
        dom.progressBar.style.width = `${percent}%`;
        let phaseText = '';
        if (phase === 'dithering') {
            phaseText = 'ディザリング中... ';
        } else {
            phaseText = '通常変換中... ';
        }
        dom.progressText.textContent = `${phaseText}${percent}%`;
    }
    
    function handleImageUpload(file) {
        const ctx = dom.resultCanvas.getContext('2d');
        ctx.clearRect(0, 0, dom.resultCanvas.width, dom.resultCanvas.height);
        dom.resultCanvas.width = 1;
        dom.resultCanvas.height = 1;
        dom.downloadBtn.disabled = true;
        dom.usedColorsSection.classList.add('hidden');
        dom.progressText.textContent = '';
        dom.progressBar.style.width = '0%';

        // 背景除去機能の状態を完全にリセット
        appState.resultImageData = null;
        appState.resultImageDataOriginal = null;
        appState.lastColorCounts = null;
        appState.lastColorCountsOriginal = null;
        appState.removeBgMode = false;
        appState.filterColorNos = [];
        appState.resultWidth = 0;
        appState.resultHeight = 0;
        
        const removeBgBtn = document.getElementById('remove-bg-btn');
        const removeBgToleranceContainer = document.getElementById('remove-bg-tolerance-container');
        if (removeBgBtn) {
            removeBgBtn.textContent = '除去オフ';
            removeBgBtn.classList.remove('bg-pink-700');
        }
        if (removeBgToleranceContainer) {
            removeBgToleranceContainer.style.display = 'none';
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            appState.originalImage = new Image();
            appState.originalImage.onload = () => {
                appState.originalAspectRatio = appState.originalImage.width / appState.originalImage.height;
                drawToCanvas(dom.originalCanvas, appState.originalImage);
                resetSizeInputs();
                dom.settingsPanel.classList.remove('disabled-panel');
                dom.settingsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
            };
            appState.originalImage.onerror = () => showError('画像ファイルの読み込みに失敗しました。');
            appState.originalImage.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    
    function drawToCanvas(canvas, imageSource) {
        const ctx = canvas.getContext('2d');
        canvas.width = imageSource.width;
        canvas.height = imageSource.height;
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (imageSource instanceof ImageData) {
            ctx.putImageData(imageSource, 0, 0);
        } else {
            ctx.drawImage(imageSource, 0, 0, canvas.width, canvas.height);
        }
    }

    function handleSizeChange(changed) {
        if (!appState.originalImage) return;
        let width = parseInt(dom.widthInput.value);
        let height = parseInt(dom.heightInput.value);

        // アスペクト比固定時、片方の値を入力したらもう片方を自動計算
        if (dom.aspectLock && dom.aspectLock.checked) {
            if (changed === 'width' && width > 0) {
                height = Math.round(width / appState.originalAspectRatio) || 1;
                dom.heightInput.value = height;
            } else if (changed === 'height' && height > 0) {
                width = Math.round(height * appState.originalAspectRatio) || 1;
                dom.widthInput.value = width;
            }
        }
        // 作品サイズ表示
        const beadSizeInfo = document.getElementById('bead-size-info');
        if (beadSizeInfo) {
            const widthInMm = width * 2.6;
            const heightInMm = height * 2.6;
            beadSizeInfo.textContent = `縦: ${heightInMm.toFixed(1)}mm 横: ${widthInMm.toFixed(1)}mm`;
        }
        // プレート必要数表示
        const plateInfo = document.getElementById('plate-info');
        if (plateInfo) {
            // プレートサイズ取得
            let plateW = 50, plateH = 50, plateName = 'NicoRate';
            const plateRadio = document.querySelector('input[name="plate"]:checked');
            if (plateRadio) {
                if (plateRadio.value === 'nicorate') { plateW = 50; plateH = 50; plateName = 'NicoRate'; }
                else if (plateRadio.value === 'fuse') { plateW = 27; plateH = 27; plateName = 'フューズビーズミニ'; }
                else if (plateRadio.value === 'nano') { plateW = 28; plateH = 28; plateName = 'ナノビーズ'; }
            }
            const platesX = Math.ceil(width / plateW);
            const platesY = Math.ceil(height / plateH);
            const platesTotal = platesX * platesY;
            plateInfo.textContent = `${plateName}プレート必要数：縦${platesY}枚 横${platesX}枚 合計${platesTotal}枚`;
        }
    }

    function resetSizeInputs() {
        if (appState.originalImage) {
            dom.widthInput.value = appState.originalImage.width;
            dom.heightInput.value = appState.originalImage.height;
            handleSizeChange();
        }
    }

    function killWorker() {
        if (appState.conversionWorker) {
            appState.conversionWorker.postMessage({ type: 'cancel' });
            appState.conversionWorker.terminate();
            appState.conversionWorker = null;
        }
    }

    function toggleConversion() {
        if (appState.isConverting) {
            killWorker();
            setUIState(false, true);
        } else {
            startConversion();
        }
    }

    function startConversion() {
        if (!appState.originalImage) return showError('最初に画像をアップロードしてください。');
        if (!appState.beadPalette || appState.beadPalette.length === 0) return showError('ビーズパレットが読み込まれていません。');
        
        const width = parseInt(dom.widthInput.value);
        const height = parseInt(dom.heightInput.value);
        if (!(width > 0 && height > 0)) return showError('有効な変換後サイズを指定してください。');
        
        setUIState(true);
        updateProgress(0, 100);
        dom.usedColorsSection.classList.add('hidden');

        const tempCtx = document.createElement('canvas').getContext('2d', { willReadFrequently: true });
        tempCtx.canvas.width = width;
        tempCtx.canvas.height = height;
        tempCtx.drawImage(appState.originalImage, 0, 0, width, height);
        const imageData = tempCtx.getImageData(0, 0, width, height);
        
        dom.resultCanvas.width = width;
        dom.resultCanvas.height = height;
        
        killWorker();
        const workerScript = document.getElementById('worker-script').textContent;
        appState.conversionWorker = new Worker(URL.createObjectURL(new Blob([workerScript])));

        appState.conversionWorker.onmessage = (e) => {
            const { type, result, current, total, phase, message } = e.data;
            switch (type) {
                case 'progress':
                    updateProgress(current, total, phase);
                    break;
                case 'complete':
                    let finalImageData = new ImageData(new Uint8ClampedArray(result.buffer), width, height);
                    let finalCounts = {...result.counts};
                    appState.resultImageData = finalImageData;
                    appState.resultImageDataOriginal = new ImageData(
                        new Uint8ClampedArray(finalImageData.data),
                        width, height
                    );
                    appState.resultWidth = width;
                    appState.resultHeight = height;
                    appState.filterColorNos = [];
                    appState.lastColorCounts = {...finalCounts};
                    appState.lastColorCountsOriginal = {...finalCounts};
                    drawFilteredResult();
                    displayColorList(finalCounts);
                    setUIState(false);
                    killWorker();
                    dom.resultContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    break;
                case 'cancelled':
                    setUIState(false, true);
                    break;
                case 'error':
                    showError(`変換エラー: ${message}`);
                    setUIState(false);
                    killWorker();
                    break;
            }
        };
        appState.conversionWorker.onerror = (err) => {
            showError(`ワーカーで致命的なエラーが発生しました: ${err.message}`);
            setUIState(false);
            killWorker();
        };

        const paletteFilterValue = dom.paletteFilter.querySelector('input:checked').value;
        const activePalette = appState.beadPalette.filter(c => paletteFilterValue === 'all' || c.categoryName === paletteFilterValue);
        
        if (activePalette.length === 0) {
            showError('選択された条件に合うビーズがありません。');
            setUIState(false);
            return;
        }
        
        const payload = {
            imageData: imageData.data.buffer,
            width, height,
            mode: dom.conversionMode.querySelector('input:checked').value,
            ditheringStrength: parseFloat(dom.ditheringSlider.value),
            activePalette,
            map: appState.beadPaletteMap,
        };
        appState.conversionWorker.postMessage({ type: 'start', payload }, [payload.imageData]);
    }

    function displayColorList(colorCounts) {
        if (!colorCounts || Object.keys(colorCounts).length === 0) {
            dom.usedColorsSection.classList.add('hidden');
            return;
        }
        // ボタンラベル更新
        if (document.getElementById('sort-count-toggle')) {
            document.getElementById('sort-count-toggle').textContent =
                appState.sortType === 'count-desc' ? '使用個数 降順' : '使用個数 昇順';
        }
        if (document.getElementById('sort-luminance-toggle')) {
            // luminance-asc: 濃い（黒い）順, luminance-desc: 明るい順
            document.getElementById('sort-luminance-toggle').textContent =
                appState.sortType === 'luminance-asc' ? '色の濃さ 濃い順' : '色の濃さ 明るい順';
        } else {
            // 初期化時は降順
            document.getElementById('sort-luminance-toggle').textContent = '色の濃さ 降順';
        }
        // 並び替え用に保存
        appState.lastColorCounts = colorCounts;
        // 並び替えロジック
        const countsArray = Object.entries(colorCounts).map(([no, count]) => {
            const c = appState.beadPaletteMap[no];
            // 色の明度L*を計算
            let luminance = 0;
            if (c) {
                // sRGB→L*（簡易）
                const r = c.r / 255, g = c.g / 255, b = c.b / 255;
                const y = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                luminance = y <= 0.008856 ? y * 903.3 : Math.pow(y, 1/3) * 116 - 16;
            }
            return { ...c, count, luminance };
        });
        // 並び順
        switch (appState.sortType) {
            case 'count-asc':
                countsArray.sort((a, b) => a.count - b.count);
                break;
            case 'count-desc':
                countsArray.sort((a, b) => b.count - a.count);
                break;
            case 'luminance-asc':
                countsArray.sort((a, b) => a.luminance - b.luminance); // 黒い順
                break;
            case 'luminance-desc':
                countsArray.sort((a, b) => b.luminance - a.luminance); // 明るい順
                break;
        }
        dom.colorListBody.innerHTML = '';
        countsArray.forEach(color => {
            if (!color) return;
            const hex = `rgb(${color.r}, ${color.g}, ${color.b})`;
            const tr = document.createElement('tr');
            tr.className = 'bg-white border-b hover:bg-slate-50 cursor-pointer';
            if (appState.filterColorNos.includes(color.no)) {
                tr.classList.add('selected-row', 'bg-blue-100');
            }
            const tdColor = document.createElement('td');
            tdColor.className = 'px-2 py-2';
            const colorDiv = document.createElement('div');
            colorDiv.className = 'w-6 h-6 rounded-full border border-slate-300 mx-auto';
            colorDiv.style.backgroundColor = hex;
            tdColor.appendChild(colorDiv);
            tr.appendChild(tdColor);

            const tdNo = document.createElement('td');
            tdNo.className = 'px-2 py-2 font-medium text-slate-900 text-center';
            tdNo.textContent = color.no;
            if (appState.filterColorNos.includes(color.no)) {
                tdNo.classList.remove('text-slate-900');
                tdNo.classList.add('text-white');
            }
            tr.appendChild(tdNo);

            const tdName = document.createElement('td');
            tdName.className = 'px-2 py-2 truncate mobile-hidden';
            tdName.textContent = color.name;
            tr.appendChild(tdName);

            const tdCount = document.createElement('td');
            tdCount.className = 'px-2 py-2 text-right';
            tdCount.textContent = color.count.toLocaleString();
            tr.appendChild(tdCount);

            dom.colorListBody.appendChild(tr);
            // 色フィルタ機能: 行クリックでフィルタ/選択解除
            tr.addEventListener('click', () => {
                if (appState.filterColorNos.includes(color.no)) {
                    // 選択解除
                    appState.filterColorNos = appState.filterColorNos.filter(no => no !== color.no);
                } else {
                    // 新たに選択
                    appState.filterColorNos.push(color.no);
                }
                drawFilteredResult();
                // 選択中の色が1つでもあればボタン表示、0なら非表示
                if (appState.filterColorNos.length > 0) {
                    dom.clearFilterBtn.style.display = '';
                } else {
                    dom.clearFilterBtn.style.display = 'none';
                }
                // リストの選択状態を再描画
                displayColorList(colorCounts);
            });
        });
        dom.usedColorsSection.classList.remove('hidden');
    }

    function downloadImage() {
        if (dom.resultCanvas.width <= 1) return;
        let url;
        if (appState.showGrid) {
            // グリッド線付き画像を一時キャンバスで生成
            const w = appState.resultWidth;
            const h = appState.resultHeight;
            const scale = 10;
            const gridColor = '#000'; // グリッド線を黒色に
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w * scale;
            tempCanvas.height = h * scale;
            const ctx = tempCanvas.getContext('2d');
            const src = appState.resultImageData.data;

            // チェッカーボード背景
            drawCheckerboard(ctx, w, h, scale, 8);

            // isPixelVisibleヘルパー関数
            const isPixelVisible = (px, py) => {
                if (px < 0 || px >= w || py < 0 || py >= h) return false;
                const i = (py * w + px) * 4;
                if (src[i + 3] < 255) return false;
                if (appState.filterColorNos.length > 0) {
                    const r = src[i], g = src[i + 1], b = src[i + 2];
                    const color = appState.beadPalette.find(c => c.r === r && c.g === g && c.b === b);
                    return color && appState.filterColorNos.includes(color.no);
                }
                return true;
            };

            // ピクセルを描画
            for (let y = 0; y < h; ++y) {
                for (let x = 0; x < w; ++x) {
                    if (isPixelVisible(x, y)) {
                        const i = (y * w + x) * 4;
                        const r = src[i], g = src[i + 1], b = src[i + 2], a = src[i + 3];
                        ctx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }

            // グリッド線を描画
            ctx.save();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            ctx.beginPath();

            // 水平線: 連結して描画
            for (let y = 0; y <= h; y++) {
                let startX = -1;
                for (let x = 0; x <= w; x++) {
                    const shouldDraw = (x < w) && (isPixelVisible(x, y - 1) || isPixelVisible(x, y));
                    if (shouldDraw && startX === -1) {
                        startX = x;
                    } else if (!shouldDraw && startX !== -1) {
                        ctx.moveTo(startX * scale, y * scale + 0.5);
                        ctx.lineTo(x * scale, y * scale + 0.5);
                        startX = -1;
                    }
                }
            }

            // 垂直線: 連結して描画
            for (let x = 0; x <= w; x++) {
                let startY = -1;
                for (let y = 0; y <= h; y++) {
                    const shouldDraw = (y < h) && (isPixelVisible(x - 1, y) || isPixelVisible(x, y));
                    if (shouldDraw && startY === -1) {
                        startY = y;
                    } else if (!shouldDraw && startY !== -1) {
                        ctx.moveTo(x * scale + 0.5, startY * scale);
                        ctx.lineTo(x * scale + 0.5, y * scale);
                        startY = -1;
                    }
                }
            }

            ctx.stroke();
            ctx.restore();
            url = tempCanvas.toDataURL('image/png');
        } else {
            url = dom.resultCanvas.toDataURL('image/png');
        }
        const link = document.createElement('a');
        link.download = 'bead-art.png';
        link.href = url;
        link.click();
    }
    
    // モーダル拡大率状態
    let modalScale = 1;
    let lastTouchDist = null;

    function showModal(sourceCanvas) {
        if (sourceCanvas.width <= 1 || sourceCanvas.height <= 1) return;
        
        const modalAspectRatio = sourceCanvas.width / sourceCanvas.height;
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        let displayWidth = screenWidth * 0.9;
        let displayHeight = displayWidth / modalAspectRatio;
        if (displayHeight > screenHeight * 0.9) {
            displayHeight = screenHeight * 0.9;
            displayWidth = displayHeight * modalAspectRatio;
        }
        dom.modalCanvas.style.width = `${displayWidth}px`;
        dom.modalCanvas.style.height = `${displayHeight}px`;
        
        // 元の画像か変換後画像かを判定
        if (sourceCanvas === dom.originalCanvas) {
            // 元の画像の場合
            const ctx = dom.modalCanvas.getContext('2d');
            dom.modalCanvas.width = sourceCanvas.width;
            dom.modalCanvas.height = sourceCanvas.height;
            ctx.drawImage(sourceCanvas, 0, 0);
        } else {
            // 変換後画像の場合
            drawFilteredModalResult();
        }
        
        dom.modal.classList.replace('hidden', 'flex');
        document.body.style.overflow = 'hidden';
        modalScale = 1;
        dom.modalCanvas.style.transform = `scale(1)`;
        dom.modalCanvas.style.transformOrigin = '50% 50%';
        dom.modal.style.alignItems = 'center';
        dom.modal.style.justifyContent = 'center';
    }

    function closeModal() {
        dom.modal.classList.replace('flex', 'hidden');
        document.body.style.overflow = '';
    }

    // モーダル拡大縮小イベント
    function setupModalZoomEvents() {
        // マウスホイール
        dom.modalCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = dom.modalCanvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 100;
            const y = ((e.clientY - rect.top) / rect.height) * 100;
            let delta = e.deltaY < 0 ? 0.1 : -0.1;
            modalScale = Math.min(5, Math.max(0.2, modalScale + delta));
            dom.modalCanvas.style.transform = `scale(${modalScale})`;
            // 画像が画面より小さい場合は中央に
            if (modalScale <= 1) {
                dom.modalCanvas.style.transformOrigin = '50% 50%';
            } else {
                dom.modalCanvas.style.transformOrigin = `${x}% ${y}%`;
            }
        }, { passive: false });
        // ピンチイン/アウト
        dom.modalCanvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                lastTouchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                // 2点の中心座標をtransform-originに
                const rect = dom.modalCanvas.getBoundingClientRect();
                const cx = ((e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left) / rect.width * 100;
                const cy = ((e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top) / rect.height * 100;
                dom.modalCanvas.style.transformOrigin = `${cx}% ${cy}%`;
            }
        });
        dom.modalCanvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastTouchDist !== null) {
                const newDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                let delta = (newDist - lastTouchDist) / 200; // 感度調整
                modalScale = Math.min(5, Math.max(0.2, modalScale + delta));
                dom.modalCanvas.style.transform = `scale(${modalScale})`;
                lastTouchDist = newDist;
                const rect = dom.modalCanvas.getBoundingClientRect();
                const cx = ((e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left) / rect.width * 100;
                const cy = ((e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top) / rect.height * 100;
                // 画像が画面より小さい場合は中央に
                if (modalScale <= 1) {
                    dom.modalCanvas.style.transformOrigin = '50% 50%';
                } else {
                    dom.modalCanvas.style.transformOrigin = `${cx}% ${cy}%`;
                }
                e.preventDefault();
            }
        }, { passive: false });
        dom.modalCanvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) lastTouchDist = null;
        });
    }

    setupModalZoomEvents();

    function drawCheckerboard(ctx, width, height, scale = 1, size = 8) {
        // チェッカーボード背景描画
        for (let y = 0; y < height; y += size) {
            for (let x = 0; x < width; x += size) {
                ctx.fillStyle = ((Math.floor(x / size) + Math.floor(y / size)) % 2 === 0) ? '#eee' : '#bbb';
                ctx.fillRect(x * scale, y * scale, size * scale, size * scale);
            }
        }
    }

    function drawFilteredResult() {
        if (!appState.resultImageData || !appState.resultWidth || !appState.resultHeight) return;
        const canvas = dom.resultCanvas;
        const ctx = canvas.getContext('2d');
        if (appState.showGrid) {
            // 50×50の画像サイズを基準としたグリッド線の太さを一定にするためのスケール計算
            const baseSize = 50; // 基準サイズ
            const baseScale = 10; // 50×50の画像で使用されるスケール
            const w = appState.resultWidth;
            const h = appState.resultHeight;
            // 50×50の画像と同じグリッド線の太さになるようにスケールを計算
            const scale = (baseSize * baseScale) / Math.max(w, h);
            
            canvas.width = w * scale;
            canvas.height = h * scale;
            // チェッカーボード背景
            drawCheckerboard(ctx, w, h, scale, 8);
            const src = appState.resultImageData.data;
            for (let y = 0; y < h; ++y) {
                for (let x = 0; x < w; ++x) {
                    const i = (y * w + x) * 4;
                    const r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];
                    const color = appState.beadPalette.find(c => c.r === r && c.g === g && c.b === b);
                    let show = true;
                    if (appState.filterColorNos.length > 0) {
                        show = color && appState.filterColorNos.includes(color.no);
                    }
                    if (a < 255) {
                        // 透過ピクセルはそのまま（checkerboardが見える）
                        continue;
                    }
                    ctx.fillStyle = show ? `rgba(${r},${g},${b},${a/255})` : '#fff';
                    ctx.fillRect(x*scale, y*scale, scale, scale);
                }
            }
        } else {
            canvas.width = appState.resultWidth;
            canvas.height = appState.resultHeight;
            // チェッカーボード背景
            drawCheckerboard(ctx, appState.resultWidth, appState.resultHeight, 1, 8);
            const src = appState.resultImageData.data;
            const dst = new Uint8ClampedArray(src.length);
            if (appState.filterColorNos.length > 0) {
                for (let i = 0; i < src.length; i += 4) {
                    const r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];
                    const color = appState.beadPalette.find(c => c.r === r && c.g === g && c.b === b);
                    if (color && appState.filterColorNos.includes(color.no)) {
                        dst[i] = r; dst[i+1] = g; dst[i+2] = b; dst[i+3] = a;
                    } else {
                        dst[i] = 255; dst[i+1] = 255; dst[i+2] = 255; dst[i+3] = 255;
                    }
                }
            } else {
                for (let i = 0; i < src.length; ++i) dst[i] = src[i];
            }
            // checkerboardの上にImageDataを描画（透過部分はcheckerboardが見える）
            ctx.putImageData(new ImageData(dst, appState.resultWidth, appState.resultHeight), 0, 0);
        }
    }

    // --- モーダル用 選択色のみ表示描画関数 ---
    function drawFilteredModalResult() {
        if (!appState.resultImageData || !appState.resultWidth || !appState.resultHeight) return;
        const canvas = dom.modalCanvas;
        const ctx = canvas.getContext('2d');
        if (appState.showGrid) {
            const scale = 10; // ピクセルを大きく見せるためのスケール
            const gridColor = '#000'; // グリッド線を黒色に
            const w = appState.resultWidth;
            const h = appState.resultHeight;
            canvas.width = w * scale;
            canvas.height = h * scale;
            const src = appState.resultImageData.data;

            // チェッカーボード背景
            drawCheckerboard(ctx, w, h, scale, 8);

            // isPixelVisibleヘルパー関数: 指定座標のピクセルが表示対象か判定
            const isPixelVisible = (px, py) => {
                if (px < 0 || px >= w || py < 0 || py >= h) return false; // 範囲外
                const i = (py * w + px) * 4;
                if (src[i + 3] < 255) return false; // 透明
                if (appState.filterColorNos.length > 0) {
                    const r = src[i], g = src[i + 1], b = src[i + 2];
                    const color = appState.beadPalette.find(c => c.r === r && c.g === g && c.b === b);
                    return color && appState.filterColorNos.includes(color.no);
                }
                return true;
            };

            // ピクセル（ビーズ）を描画
            for (let y = 0; y < h; ++y) {
                for (let x = 0; x < w; ++x) {
                    if (isPixelVisible(x, y)) {
                        const i = (y * w + x) * 4;
                        const r = src[i], g = src[i + 1], b = src[i + 2], a = src[i + 3];
                        ctx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
                        ctx.fillRect(x * scale, y * scale, scale, scale);
                    }
                }
            }

            // --- グリッド描画ロジック（最終修正版） ---
            ctx.save();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            ctx.beginPath();

            // 水平線: 連結して描画
            for (let y = 0; y <= h; y++) {
                let startX = -1;
                for (let x = 0; x <= w; x++) {
                    const shouldDraw = (x < w) && (isPixelVisible(x, y - 1) || isPixelVisible(x, y));
                    if (shouldDraw && startX === -1) {
                        startX = x;
                    } else if (!shouldDraw && startX !== -1) {
                        ctx.moveTo(startX * scale, y * scale + 0.5);
                        ctx.lineTo(x * scale, y * scale + 0.5);
                        startX = -1;
                    }
                }
            }

            // 垂直線: 連結して描画
            for (let x = 0; x <= w; x++) {
                let startY = -1;
                for (let y = 0; y <= h; y++) {
                    const shouldDraw = (y < h) && (isPixelVisible(x - 1, y) || isPixelVisible(x, y));
                    if (shouldDraw && startY === -1) {
                        startY = y;
                    } else if (!shouldDraw && startY !== -1) {
                        ctx.moveTo(x * scale + 0.5, startY * scale);
                        ctx.lineTo(x * scale + 0.5, y * scale);
                        startY = -1;
                    }
                }
            }

            ctx.stroke();
            ctx.restore();

        } else {
            canvas.width = appState.resultWidth;
            canvas.height = appState.resultHeight;
            // チェッカーボード背景
            drawCheckerboard(ctx, appState.resultWidth, appState.resultHeight, 1, 8);
            const src = appState.resultImageData.data;
            const dst = new Uint8ClampedArray(src.length);
            if (appState.filterColorNos.length > 0) {
                for (let i = 0; i < src.length; i += 4) {
                    const r = src[i], g = src[i+1], b = src[i+2], a = src[i+3];
                    const color = appState.beadPalette.find(c => c.r === r && c.g === g && c.b === b);
                    if (color && appState.filterColorNos.includes(color.no)) {
                        dst[i] = r; dst[i+1] = g; dst[i+2] = b; dst[i+3] = a;
                    } else {
                        dst[i] = 255; dst[i+1] = 255; dst[i+2] = 255; dst[i+3] = 255;
                    }
                }
            } else {
                for (let i = 0; i < src.length; ++i) dst[i] = src[i];
            }
            ctx.putImageData(new ImageData(dst, appState.resultWidth, appState.resultHeight), 0, 0);
        }
    }

    // --- 追加: ラジオボタンの設定保存・復元 ---
    function saveRadioSetting(name) {
        const checked = document.querySelector(`input[name="${name}"]:checked`);
        if (checked) {
            localStorage.setItem(`beadchanger-setting-${name}`, checked.value);
        }
    }
    function restoreRadioSetting(name) {
        const saved = localStorage.getItem(`beadchanger-setting-${name}`);
        if (saved) {
            const radio = document.querySelector(`input[name="${name}"][value="${saved}"]`);
            if (radio) radio.checked = true;
        }
    }

    // --- 色差計算 ---
    function colorDistance(r1, g1, b1, r2, g2, b2) {
        return Math.sqrt((r1-r2)**2 + (g1-g2)**2 + (b1-b2)**2);
    }
    // --- 背景除去フラッドフィル ---
    function removeBackgroundFloodFill(x, y, tolerance) {
        const w = appState.resultWidth;
        const h = appState.resultHeight;
        const data = appState.resultImageData.data;
        const idx = (y * w + x) * 4;
        const target = [data[idx], data[idx+1], data[idx+2]];
        const visited = new Uint8Array(w * h);
        const queue = [[x, y]];
        const removedCounts = {};

        while (queue.length) {
            const [cx, cy] = queue.pop();
            if (cx < 0 || cy < 0 || cx >= w || cy >= h) continue;
            const i = (cy * w + cx) * 4;
            if (visited[cy * w + cx]) continue;
            if (data[i+3] === 0) continue; // 既に透明
            // 色番号を特定
            const color = appState.beadPalette.find(c => c.r === data[i] && c.g === data[i+1] && c.b === data[i+2]);
            // 限定色モード時は選択色以外は除去しない
            if (appState.filterColorNos.length > 0 && (!color || !appState.filterColorNos.includes(color.no))) continue;
            if (colorDistance(data[i], data[i+1], data[i+2], ...target) <= tolerance) {
                if (color) {
                    removedCounts[color.no] = (removedCounts[color.no] || 0) + 1;
                }
                data[i+3] = 0; // 透明化
                visited[cy * w + cx] = 1;
                queue.push([cx-1, cy]);
                queue.push([cx+1, cy]);
                queue.push([cx, cy-1]);
                queue.push([cx, cy+1]);
            }
        }

        // 使用色リストの個数を減算
        if (appState.lastColorCounts) {
            for (const [no, count] of Object.entries(removedCounts)) {
                if (appState.lastColorCounts[no]) {
                    appState.lastColorCounts[no] -= count;
                    if (appState.lastColorCounts[no] <= 0) {
                        delete appState.lastColorCounts[no];
                    }
                }
            }
        }

        drawFilteredResult();
        displayColorList(appState.lastColorCounts);
    }

    // 減色バーの最大値・ラベルをパレットに応じて更新
    function updateColorReduceSliderMax() {
        if (!dom.colorReduceSlider) return;
        const paletteFilterValue = dom.paletteFilter.querySelector('input:checked').value;
        const activePalette = appState.beadPalette.filter(c => paletteFilterValue === 'all' || c.categoryName === paletteFilterValue);
        const max = Math.max(1, activePalette.length);
        dom.colorReduceSlider.max = max;
        if (parseInt(dom.colorReduceSlider.value) > max) dom.colorReduceSlider.value = max;
        dom.colorReduceMaxLabel.textContent = `${max}色`;
    }

    initializeApp();
    </script>
</body>
</html>
